using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEditor;
using UnityEngine;

namespace HeurekaGames.AssetHunterPRO.BaseTreeviewImpl.AssetTreeView
{
    [Serializable]
    public class AH_BuildInfoTreeView : ScriptableObject, ISerializationCallbackReceiver
    {
        [SerializeField] private List<AH_TreeviewElement> m_TreeElements;

        private List<Texture> serializationHelperListIconTextures;

        //Serialization helper lists
        private List<string> serializationHelperListIconTypes;

        internal List<AH_TreeviewElement> treeElements
        {
            get => m_TreeElements;
            set => m_TreeElements = value;
        }

        public void OnEnable()
        {
            hideFlags = HideFlags.HideAndDontSave;
        }

        public bool PopulateTreeView(AH_SerializedBuildInfo chosenBuildInfo)
        {
            //Todo, maybe not get ALL assets, but just the assets in the project folder (i.e. -meta etc)?
            treeElements = new List<AH_TreeviewElement>();

            var depth = -1;
            var id = 0;

            var root = new AH_TreeviewElement("Root", depth, id, "", "", new List<string>(), false);

            treeElements.Add(root);

            depth++;
            id++;

            //This is done because I cant find all assets in toplevel folders through the Unity API (Remove whem the API allows it)
            var folderCount = Directory.GetDirectories(Application.dataPath, "*", SearchOption.AllDirectories).Count();
            var foldersProcessed = 0;

            var populatedSuccesfully = AddFilesRecursively(Application.dataPath, chosenBuildInfo, depth, ref id,
                folderCount, ref foldersProcessed);

            //Cleanup garbage
            AssetDatabase.Refresh();
            GC.Collect();

            //Create tree
            if (populatedSuccesfully)
                TreeElementUtility.ListToTree(treeElements);

            EditorUtility.ClearProgressBar();

            return populatedSuccesfully;
        }

        private bool AddFilesRecursively(string absPath, AH_SerializedBuildInfo chosenBuildInfo, int treeViewDepth,
            ref int treeViewID, int folderCount, ref int foldersProcessed)
        {
            string relativePath;
            string folderID;
            AH_Utils.GetRelativePathAndAssetID(absPath, out relativePath, out folderID);

            //For some reason streamingassets folders are generated by unity when building, only to be deleted immediately after. Need to take that under consideration here.
            if (!AssetDatabase.IsValidFolder(relativePath)) return false;

            //Increment folder process count
            foldersProcessed++;
            var progress = foldersProcessed / (float)folderCount;
            EditorUtility.DisplayProgressBar($"Analyzing project ({foldersProcessed}/{folderCount}", relativePath,
                progress); //Todo make cancellable

            //Check if this folder has been Ignored
            if (AH_SettingsManager.Instance.HasIgnoredFolder(relativePath, folderID))
                return false;

            //Add folder
            var dirInfo = new DirectoryInfo(absPath);
            var dirInfoName = dirInfo.Name;

            //Increment ID
            treeViewID++;

            //TODO creating new treeviewelements loads asset from memory...DONT DO THAT!! Get filesize info somewhere else
            var threeViewFolder = new AH_TreeviewElement(dirInfoName, treeViewDepth, treeViewID,
                treeViewDepth != -1 ? relativePath : "", "", null, false);
            treeElements.Add(threeViewFolder);

            //Increment depth
            treeViewDepth++;

            //Track if this folder has valid children
            var hasValidChildren = false;

            foreach (var assetPath in
                     Directory.GetFiles(absPath)
                         .Where(val => Path.GetExtension(val) != ".meta")) // !val.EndsWith(".meta")))
            {
                string relativepath;
                string assetID;
                AH_Utils.GetRelativePathAndAssetID(assetPath, out relativepath, out assetID);

                //If this is not an unity asset
                if (string.IsNullOrEmpty(assetID))
                    continue;

                //Has this file been Ignored?
                if (AH_SettingsManager.Instance.HasIgnoredAsset(relativepath, assetID))
                    continue;

                var usedAssetInfo = chosenBuildInfo.GetItemInfo(assetID);
                var isAssetUsed = usedAssetInfo != null;

                //TODO CONTINUE LOOP AND ADDING OF ASSETS
                treeViewID++;
                var treeViewElement = new AH_TreeviewElement(assetPath, treeViewDepth, treeViewID, relativepath,
                    assetID, isAssetUsed ? usedAssetInfo.Refs : null, isAssetUsed);
                treeElements.Add(treeViewElement);

                hasValidChildren = true;
            }

            foreach (var dir in Directory.GetDirectories(absPath))
                if (AddFilesRecursively(dir, chosenBuildInfo, treeViewDepth, ref treeViewID, folderCount,
                        ref foldersProcessed))
                    hasValidChildren = true;

            if (!hasValidChildren && treeViewDepth != -1)
            {
                treeElements.Remove(threeViewFolder);
                //Decrement ID
                treeViewID--;

                //Decrement depth
                treeViewDepth--;
            }

            //Return true if folder added succesfully
            return hasValidChildren;
        }

        internal bool HasUnused()
        {
            var hasUnused = m_TreeElements.Any(val => !val.UsedInBuild && !val.IsFolder && val.depth != -1);
            return hasUnused;
        }

        private string[] getAssetsOfType(Type type)
        {
            return AssetDatabase.FindAssets("t:" + type.Name);
        }

        #region Serialization callbacks

        //Store serializable string so we can retrieve type after serialization
        public void OnBeforeSerialize()
        {
            serializationHelperListIconTypes = AH_TreeviewElement.GetStoredIconTypes();
            serializationHelperListIconTextures = AH_TreeviewElement.GetStoredIconTextures();
        }

        public void OnAfterDeserialize()
        {
            AH_TreeviewElement.UpdateIconDictAfterSerialization(serializationHelperListIconTypes,
                serializationHelperListIconTextures);
            serializationHelperListIconTypes = null;
            serializationHelperListIconTextures = null;
        }

        #endregion
    }
}